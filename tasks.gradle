// build jar
void jarTask(String name, String classifier, boolean withJar) {
    // tasks.create(name: name, type: Jar) {
    tasks.register(name, Jar) {
        group 'build'
        archiveClassifier.set classifier
        // leave the file/entry that was first copied/created in place
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA', 'META-INF/*.MF'

        manifest.from jar.manifest
        from {
            // findAll { it.name.endsWith('.jar') }: filter something else, such as *.pom
            configurations.runtimeClasspath.findAll { it.name.endsWith('.jar') }.collect { zipTree(it) }
        }
        if (withJar) {
            // from sourceSets.main.output
            with jar
        }
    }
}

plugins.withType(JavaPlugin) {
    // zip all classes include deps to a fat jar
    jarTask('fatJar', 'all', true)
    // copy all dep jar to a dir
    jarTask('depJar', 'dep', false)

    task allJar {
        group 'build'
        dependsOn jar, depJar, fatJar
    }

    tasks.register("copyDep", Copy) {
        destinationDir file("${buildDir}/dep")
        from {
            configurations.runtimeClasspath.findAll { it.name.endsWith('.jar') }.collect { file(it) }
        }
    }

    // print all dep flatly
    tasks.register("descDep") {
        configurations.runtimeClasspath.findAll { it.name.endsWith('.jar') }.forEach {
            println(it.name)
        }
    }
}
